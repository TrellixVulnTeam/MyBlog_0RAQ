# 目录

[TOC]

# Unit 1 : 绪论

1. 数据元素是数据的基本单位。一个数据元素可由若干个数据项组成。

2. 数据对象是性质相同的数据元素的集合，是数据的一个子集。

3. 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据元素之间的关系称为结构，四类基本结构：

   * 集合：除了同属一个集合，别无其他关系。
   * 线性结构：存在一对一的关系。
   * 树形结构：存在一对多的关系。
   * 图状结构或网状结构：存在多个对多个的关系。

4. 数据结构的形式定义：`Data_Structure = (D, S)`，其中D是数据元素的有限集，S是D上关系的有限集。

5. 数据结构在计算机中的表示称为数据的物理结构，又称为存储结构。数据元素之间的关系在计算机中有顺序映像和非顺序映像两种表示方法，由此得到两种不同的存储结构：顺序存储结构和链式存储结构。

6. 数据类型是一个值的集合和定义在这个值集上的一组操作的总称，可分为：

   * 原子类型：例如C语言的基本类型，整型、实型、字符型等等。
   * 结构类型：如数组。

7. 抽象数据类型（ADT）,是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，与其在计算机内部的表示和实现无关。抽象数据类型可分为：

   * 原子类型
   * 固定聚合类型
   * 可变聚合类型

   抽象数据类型可由三元组（D，S，P）表示，D为数据对象，S是D上的关系集，P是对D的基本操作集。

8. 多形数据类型是指其值的成分不确定的数据类型。

9. 算法是对特定问题求解步骤的一种描述，是指令的有限序列，每条指令表示一个或多个操作。算法的五个重要特性：

   * 有穷性
   * 确定性
   * 可行性
   * 输入（0个或多个）
   * 输出（一个或多个）

10. 算法设计的要求：

    * 正确性
    * 可读性
    * 健壮性
    * 效率和低储存量需求·

11. 算法性能分析：

    * 硬件的速度
    * 书写程序的语言
    * 编译程序所生成的目标代码质量
    * 问题的规模

12. 算法的时间复杂度和空间复杂度。

# Unit 2 : 线性表

1. 线性表是n个数据元素的有限序列。

2. 一个数据元素可由若干个数据项组成，在这种情况下常常把数据元素成为记录，含有大量记录的线性表又称文件。

3. 线性表的基本操作：

   ```
   InitList(&L)
   DestroyList(&L)
   ClearList(&L)
   ListEmpty(L)
   ListLength(L)
   GetElem(L, i, &e)
   LocateElem(L, e, compare())
   PriorElem(L, cur_e, &pre_e)
   NextElem(L, cur_e, &next_e)
   ListInsert(&L, i, e)	//复杂度为O(n)
   ListDelete(&L, i, &e)	//复杂度为O(n)
   ListTraverse(L, visit())
   ```

4. 线性表的顺序存储：

   ```C
   typedef struct{
   	ElemType *elem;
   	int length;
   	int listsize;
   }SqList;
   ```

5. 线性表的链式表示：

   ```C
   typedef struct LNode{
   	ELemType data;
   	struct LNode *next;
   }LNode,*List;
   ```

6. 静态链表：

   ```C
   typedef struct jn{
   	ElemType data;
   	int cur;
   }JNode, JList[MAXSIZE];
   ```

7. 循环链表：链表中最后一个结点指向头结点。

8. 双向链表：

   ```C
   typedef struct dn{
   	ElemType data;
   	struct dn *prior;
   	struct dn *next; 
   }DNode,*DList
   ```

# Unit 3 : 栈和队列

1. 栈是限定仅在表尾进行插入或删除的线性表。

2. 栈的基本操作：

   ```
   InitStack(&S)
   DestroyStack(&S)
   ClearStack(&S)
   StackEmpty(S)
   StackLength(S)
   GetTop(S, &e)
   Push(&S, e)
   Pop(&S, &e)
   StackTraverse(S, visit())
   ```

3. 顺序栈：

   ```c
   typedef struct snode{
   	ElemType *top;
   	ElemType *bottom;
   	int stacksize;
   }Stack;
   ```

4. 栈和递归的实现。

5. 队列是一种先进先出的线性表。

6. 队列的基本操作：

   ```
   InitQueue(&Q)
   DestroyQueue(&Q)
   ClearQueue(&Q)
   QueueEmpty(Q)
   QueueLength(Q)
   GetHead(Q, &e)
   EnQueue(&Q, e)
   Dequeue(&Q, &e)
   QueueTraverse(Q, visit())
   ```

7. 链队列：

   ```C
   typedef struct qn{
   	ElemType data;
   	struct qu *next
   }QNode, *QPtr;
   typedef struct q{
   	QPtr front;
   	QPtr rear;
   }Queue;
   ```

8. 循环队列：

   ```c
   typedef struct sq{
   	ElemType *base;
   	int front;
   	int rear;
   }SqQueue
   ```

# Unit 4 : 串

1. 串是由零个或多个字符组成的有限序列。

2. 串中任意个连续的字符组成的子序列称为该串的子串。

3. 基本操作：

   ```
   StrAssigh(&T, chars)
   StrCopy(&T, S)
   StrEmpty(S)
   StrCompare(S, T)
   StrLength(S)
   ClearString(&S)
   Concat(&T, S1, S2)
   SUbString(&Sub, S, pos, len)
   Index(S, T, pos)
   Replace(&S, T, V)
   StrInsert(&S, pos, T)
   StrDelete(&S, pos, len)
   DestroyString(&S)
   ```

4. 串的定长顺序表示：

   ```c
   typedef unsighed cahr SString[MAXSIZE + 1];	//0号位储存长度
   ```

   堆分配存储表示：

   ```c
   typedef struct{
   	char *ch;
   	int length;
   }HString;
   ```

   串的块链存储表示：

   ```C
   typedef struct Chunk{
   	char ch[CHUNKSIZE];
   	struct chunk *next;
   }Chunk;
   typedef struct ls{
   	Chunk *head,  *tail;
   	int curlen;
   }LString;
   ```

5. **串的模式匹配算法**：

   * 简单但效率低下的普通算法：

     ```C
     int Index(String a, String b, int pos){
     	int pa = pos, pb = 1;
     	while(pa <= a[0] && pb <= b[0]){
     		if(a[pa] == b[pb]){
     			pa++;
     			pb++;
     		}else{
     			pa = pa - pb + 1;
     			pb = 1;
     		}
     	}
     	if(pb > b[0]) return (pa - b[0]);
         else return 0;
     }
     ```

   * **高效的KMP算法**：(我的程序好像有一点问题)

     ```C
     // 计算next数组
     void get_next(string a, int next[]){
         i = 1, j = 0, next[1] = 0;
         while(i < a[0]){
             if(j == 0 || a[i] == a[j]){
                 next[++i] = ++j;
             }else{
                 j = next[j]; 
             }
         }
     }
     
     // 计算nextval数组, 比next数组更好
     void get_nextval(string a, int nextval[]){
         i = 1, j = 0, nextval[1] = 0;
         while(i < a[0]){
             if(j == 0 || a[i] == a[j]){
                 i++, j++;
                 if(a[i] != a[j]) nextval[i] = j;
                 else nextval[i] = nextval[j];
             }else{
                 j = nextval[j];
             }
         }
     }
     
     // 匹配函数主体
     int IndexKMP(string a, string b, int pos){
         i = pos, j = 1;
         while(i <= a[0] && j <=b[0]){
             if(j == 0 || a[i] == b[j]){
                 i++, j++;
             }else{
                 j = nextval[j];
             }
         }
         if(j > b[0]) return (i - b[0]);
         else return 0;
     }
     ```


# Unit 5 : 数组和广义表

1. 数组的顺序存储：

   ```C
   typedef struct {
       ElemType *base;
       int dim;//维数
       int *bounds;//存储每一维的长度
       int *constants;//某一维度的“1”所占空间
   }Array;
   ```

2. 特殊矩阵与稀疏矩阵。

3. 稀疏矩阵的表示：

   * 三元组顺序表：

   ```C
   typedef struct tn{
   	int i, j;
   	ElemType e;
   }Triple;
   typedef struct{
       Triple data[MAXSIZE+1];
       int mu, nu, tu;//行数、列数、非零元个数
   }Matrix;
   ```

   * 行逻辑链接的顺序表：

   ```c
   typedef struct tn{
   	int i, j;
   	ElemType e;
   }Triple;
   typedef struct{
       Triple data[MAXSIZE+1];
       int rpos[MAXRC+1];
       int mu, nu, tu;//行数、列数、非零元个数
   }Matrix;
   ```

   * 十字链表：

   ```c
   typedef struct qn{
   	int i, j;
   	ELemType e;
   	struct qn *right;
   	struct qn *down;
   }QNode, *QPtr;
   typedef struct cl{
       QPtr *rhead, *chead;
       int mu, nu, tu; 
   }
   ```

4. 广义表非空时，称第一个元素a1为表头，其余元素组成的表称为表尾。

5. 广义表的存储结构：

   ```c
   typedef struct gln{
   	ElemTag tag;
   	union{
   		AtomType atom;
   		struct{
   			struct gln *hp, *tp;
   		}ptr;
   	}
   }*GList;
   ```

# Unit 6 : 树和二叉树

1. 树的基本操作：

   ```
   InitTree(&T)
   DestroyTree(&T)
   CreateTree(&T, definition)
   ClearTree(&T)
   TreeEmpty(T)
   TreeDepth(T)
   Root(T)
   Value(T, cur_e)
   Assign(T, cur_e, value)
   Parent(T, cur_e)
   LeftChild(T, cur_e)
   RIghtSibling(T, cur_e)
   InsertChild(&T, &p, i, c)
   DeleteChild(&T, &T, i)
   TraverseTree(T, visit())
   PreOrderTraverse(T, visit())
   InOrderTraverse(T, visit())
   PostOrderTraverse(T, visit())
   LevelOrderTraverse(T, visit())
   ```

2. 二叉树：每个结点至多只有两颗子树，且子树有左右之分.

3. 二叉树的性质：

   1. 在第i层上至多有$2^{i-1}$个结点

   2. 深度为k的二叉树至多有$2^{k}-1$个结点
   3. 对任意一颗二叉树，设其终端结点数位$n_0$, 度为2的结点数为$n_2$， 则有$n_0 = n_2 + 1$。

4. **满二叉树**：深度为k且含有$2^k-1$个结点的二叉树。

5. **完全二叉树**：每个顶点的编号均与对应的满二叉树的编号一致。

   1. 具有n个结点的完全二叉树的深度为$\lfloor\log_2{n}\rfloor+1$。
   2. 若有左孩子，则结点$2i$是结点$i$的左孩子；若有右孩子，则结点$2i+1$是结点$i$的右孩子。

6. 二叉树的存储结构：

   ```C
   /*顺序存储*/
   typedef ELemType Tree[MAXSIZE];
   
   /*链式存储*/
   typedef struct tn{
       ELemType data;
       struct tn *lchild, *right;
   }
   ```

7. **二叉树的遍历**：

   ```c
   #include <iostream>
   #include <queue>
   #include <stack>
   using namespace std;
   
   typedef struct tn{
       int data;
       struct tn *lchild, *rchild;
   }TNode, *Tree;
   
   /*递归建立二叉树*/
   void CreateTree(Tree &T){
       int a;
       cin>>a;
       if(a != -1){
           T = new TNode;
           T->data = a;
           CreateTree(T->lchild);
           CreateTree(T->rchild);
       }else{
           T = nullptr;
       }
   }
   
   /*先序遍历*/
   /*递归版本*/
   void PreOrderTraverse(Tree T){
       if(T == nullptr) return;
       else{
           cout<<T->data<<" ";
           PreOrderTraverse(T->lchild);
           PreOrderTraverse(T->rchild);
       }
   }
   /*非递归版*/
   void PreOrderTraverse_f(Tree T){
       stack <Tree> s;
       Tree k = T;
       while(k || !s.empty()){
           while(k){
               cout<<k->data<<" ";
               s.push(k);
               k = k->lchild;
           }
           k = s.top()->rchild;
           s.pop();
       }
   }
   
   /*中序遍历*/
   /*递归*/
   void InOrderTraverse(Tree T){
       if(T == nullptr) return;
       InOrderTraverse(T->lchild);
       cout<<T->data<<" ";
       InOrderTraverse(T->rchild);
   }
   /*非递归*/
   void InOderTraverse_f(Tree T){
       stack<Tree> s;
       Tree k = T;
       while(k || !s.empty()){
           while(k){
               s.push(k);
               k = k->lchild;
           }
           cout<<s.top()->data<<" ";
           k = s.top()->rchild;
           s.pop();
       }
   }
   
   /*后序遍历*/
   /*递归*/
   void PostOrderTraverse(Tree T){
       if(T == nullptr) return;
       PostOrderTraverse(T->lchild);
       PostOrderTraverse(T->rchild);
       cout<<T->data<<" ";
   }
   /*非递归*/
   void PostOrderTraverse_f(Tree T){
       stack<Tree> s;
       Tree k = T, m = nullptr, pre = nullptr;
       while(k || !s.empty()){
           while(k){
               s.push(k);
               k = k->lchild;
           }
           m = s.top()->rchild;
           if(m == nullptr || m == pre){
               cout<<s.top()->data<<" ";
               pre = s.top();
               s.pop();
           }else{
               k = m;
           }
       }
   }
   
   /*层序遍历*/
   void LevelOrderTraverse(Tree T){
       queue<Tree> q;
       if(T == nullptr) return;
       q.push(T);
       while(!q.empty()){
           Tree k = q.front();
           cout<<k->data<<" ";
           if(k->lchild) q.push(k->lchild);
           if(k->rchild) q.push(k->rchild);
           q.pop();
       }
   }
   
   
   int main() {
       Tree T;
       CreateTree(T);
       PreOrderTraverse(T);
       cout<<endl;
       PreOrderTraverse_f(T);
       cout<<endl;
       InOrderTraverse(T);
       cout<<endl;
       InOderTraverse_f(T);
       cout<<endl;
       PostOrderTraverse(T);
       cout<<endl;
       PostOrderTraverse_f(T);
       cout<<endl;
       LevelOrderTraverse(T);
       cout<<endl;
       return 0;
   }
   ```

8. 线索二叉树：在二叉树的基础上添加两个标志域LTag：值为0表示lchild指示结点的左孩子，值为1表示lchild指示结点的前驱，RTag：值为0表示rchild指示结点的左孩子，值为1表示rchild指示结点的后继。

   其中指示前驱和后继的指针叫做线索。

9. 树的孩子兄弟表示法：

   ```c
   typedef struct tn{
   	ElemType data;
   	struct tn *firstchild, *nextsibling;
   }TNode, *Tree;
   ```

10. 树和森林的转换，森林的遍历。（需要了解，但不难）

11. **赫夫曼树与赫夫曼编码**(重要，但并不难)。

12. 树的计数：有着n个结点的不相似的二叉树有$\frac{1}{n+1}C_{2n}^{n}$棵。

# Unit 7 : 图

1. 图的基本操作：

   ```
   CreateGraph(&G, Vex, Arc)
   DestroyGraph(&G)
   LocateVex(G, u)
   GetVex(G, v)
   PutVex(&G, v, value)
   FirstAdjVex(G, v)
   NextAdjVex(G, v)
   InsertVex(&G, v)
   DeleteVex(&G, v)
   InsertArc(&G, v, w)
   DeleteArc(&G, v, w)
   DFSTraverse(G, visit())
   BFSTraverse(G, visit())
   ```

2. 图的存储结构

   ```C
   /*邻接矩阵*/
   typedef struct ArcCell{
   	VRType adj;
   	InfoType *info;
   }ArcCell, AdjMatrix[MAX1][MAX2];
   typedef struct mg{
       VexType vexs[MAX1];
       AdjMatrix arcs;
       int vexnum, arcnum;
       int kind;
   }
   
   /*邻接表*/
   typedef struct ArcNode{
       int adjvex;
       struct ArcNode *nextarc;
       InfoType *info;
   }ArcNode;
   typedef struct VNode{
       VexType data;
       ArcNode *firstarc;
   }VNode, AdjList[MAX1];
   typedef struct ag{
       AdjList vexs;
       int vexnum, arcnum;
       int kind;
   }ALGraph;
   
   /*还有逆邻接表、十字链表、邻接多重表等等*/
   ```

3. **图的遍历**

   ```C
   /*深度优先搜索*/
   void DFSTraverse(Graph G){
       for(v = 0; v < G.vexnum; v++){
           visit[v] = False;
       }
       for(v = 0; v < G.vexnum; v++){
           if(!visit[v]) DFS(G, v);
       }
   }
   void DFS(G, v){
       visit[v] = True;
       cout<<G.vexs[v]->data<<" ";
       for(w = FirstAdjVex(G, v); w > 0; w = NextAdjVex(G, v, w)){
           if(!visit[w]) DFS(G, w);
       }
   }
   
   /*广度优先搜索*/
   void BFSTraverse(Graph G){
       queue<int> q;
       for(v = 0; v < G.vexnum; v++){
           visit[v] = False;
       }
       for(v = 0; v < G.vexnum; v++){
           if(!visit[v]){
               q.push(v);
               visit[v] = True;
               cout<<G.vexs[v]->data<<" ";
               while(!q.empty()){
                   k = q.front();
                   for(w = FirstAdjVex(G, k); w > 0; w = NextAdjVex(G, k, w)){
           			if(!visit[w]){
                           visit[w] = True;
                           cout<<G.vexs[v]->data<<" ";
                           q.push(w);
                       }
       			}
               }
           }
       }
   }
   ```

   

4. **最小生成树**

   ```C
   /*Prim算法*/
   void MiniSpanTree_PRIM(MGraph G, int k){
   	for(j = 0;j < G.vexnum; j++){
   		if(j != k){
   			closedis[j] = dis[k][j];
   		}
   	}
       closedis[k] = 0;
       for(i = 1; i < G.vexnum; ++i){
           min = 9999;
           for(j = 0; j < G.vexnum; j++){
               if(closedis[j] != 0 && closedis[j] < min){
                   k = j;
               }
           }
           //输出相关信息， cout<<......
           closedis[k] = 0;
           for(j = 0; j < vexnum; ++j){
               if(dis[k][j] < closedis[j]){
                   closedis[j] = dis[k][j];
               }
           }
       }
   }
   /*Prim算法的复杂度与网中的边数无关，因此适合求便稠密的网的最小生成树*/
   ```

5. 关节点与重连通分量：
   $$
   low(v) = min\left\{visited[v],low[w], visited[k]\right\}
   $$
   其中w是顶点在深度优先生成树中的孩子结点，k是顶点v在深度优先生成树上回边联结的祖先顶点。

   倘若有某个顶点v，存在某个孩子结点w且$low[w]>visited[v]$, 则v为关节点。

6. **拓扑排序**：

   ```C
   void TopoSort(Graph G){
       count = 0;
   	GetInDegree(G,indegree)//对图中顶点求入度，并把数据存储到indegree数组中
   	stack<int> s;
   	for(i = 0; i < G.vexnum; ++i){
   		if(!indegree[i]){
   			s.push(i);
   		}
   	}
   	while(!s.empty()){
   		//输出s.top()元素的相关信息,cout<<...
           k = s.top();
           for(w = FirstAdjVex(G, k); w > 0; w = NexAdjVex(G, k, w)){
               indegree[w]--;
               if(indegree[w] == 0) s.push(w);
           }
           s.pop();
           count++;
   	}
       if(count < G.vexnum) //输出或返回相关信息，表明该图非连通
       else //ok
   }
   ```

   **关键路径**：

   利用栈进行**逆拓扑排序**，求得时间的最迟发生时间，与最早发生时间比较后，即可判断是否为关键活动。

7. **最短路径**

   ```c
   /*单源最短路径*/
   /*Dijkstra算法*/
   void ShortestPath_DIJ(Graph G, int v){
   	for(i = 0; i < G.vexnum; i++){
   		visit[i] = False;//visit数组将用来储存那些已经确定了最短路径的顶点
   		dis[i] = G.arcs[v][i];//dis数组用来存储最短路径的大小，初始值设为点到源(起始点)的距离
   		for(j = 0; j < G.vexnum; j++){
   			Path[i][j] = False;
   /*Path数组用来存储最短路径经过的具体点，Path[v][w]的真假表示从起始点到v的最短路径上是否经过了w点*/
   		}
   		if(dis[i] < INFINITY){/*能够确保一定能到达i点,则i点和v点都必在最短路径中*/
   			Path[i][v] = True;
   			Path[i][i] = True;
   		}
   	}
   	visit[v] = True;
   	dis[v] = 0;
   	for(i = 1; i < G.vexnum; i++){//循环“顶点数-1”次
   		min = INFINITY;
   		for(w = 0; w < G.vexnum; w++){
   			if(!visit[w] && dis[w] < min){
   				k = w;
   			}
   		}
   		visit[k] = True;
   		/*更新最短路径*/
   		for(w = 0; w < G.vexnum; w++){
               if(!visit[w] && (dis[k] + G.arcs[k][w] < dis[w])){
                   dis[w] = dis[k] + G.arcs[k][w];
                   Path[w] = Path[k];//继承从源(起始点)到k的这段路径
                   Path[w][w] = True;
               }
           }
   	}
   }
   
   /*多元最短路径*/
   /*Floyd算法*/
   void ShortestPath_FLOYD(Graph G){
       /*初始化*/
       for(i = 0; i < G.vexnum; i++){
           for(j = 0; j < G.vexnum; i++){
               dis[i][j] = G.arcs[i][j];
               for(u = 0; u < G.vexnum; u++){
                   Path[i][j][u] = False;
               }
               if(dis[i][j] < INFINITY){
                   P[i][j][i] = True;
                   P[i][j][j] = True;
               }
           }
       }
       /*更新最短路径矩阵*/
       for(mid = 0; mid < G.vexnum; mid++){
       	for(i = 0; i < G.vexnum; i++){
           	for(j = 0; j < G.vexnum; i++){
                   if(dis[i][mid] + dis[mid][j] < dis[i][j]){
                       dis[i][j] = dis[i][mid] + dis[mid][j];
                       for(w = 0; w < G.vexnum; w++){
                           P[i][j][w] = P[i][mid][w] || P[mid][j][w];
                       }
                   }
               }
           }
       }
   }
   ```


# Unit 8 : 查找

1. **折半查找**

   ```c
   void Binary_Search(List L, KeyType key){
   	low = 1, high = length;
   	while(low <= high){
   		mid = (low + high) / 2;
   		if(key == L[mid].key) return mid;
   		if(key > L[mid].key) low = mid + 1;
   		else high = mid - 1;
   	}
   	return -1;
   }
   ```

2. 静态最优查找树的建立、索引顺序表的查找(需要理解其中的思想)。

3. **二叉排序树**：

   * 二叉排序树的性质：

     1. 若左子树不为空，则左子树上所有顶点的值均小于它的根结点的值。
     2. 若右子树不为空，则右子树上所有顶点的值均大于它的根结点的值。
     3. 左右子树均为二叉排序树

   * 二叉排序树的查找、插入和删除：

     ```c
     /*查找*/
     bool Search(BiTree T, KeyType key, BiTree fa){
         if(T == nullptr){
             p = fa;///fa为T结点的父节点
             return False;
         }else if(key == T->data.key){
             p = T;
             return True;
         }else if(key < T->data.key){
             return Search(T->lchild, key, T);
         }else{
             return Search(T->rchild, key, T);
         }
     }
     
     /*插入*/
     bool Insert(BiTree &T, ElemType e){
         if(!Search(T, e.key, nullptr)){
             pnode = new BiTNode;
             pnode->data = e;
             pnode->lchild = pnode->rchild = nullptr;
             if(p == nullptr) T = pnode;
             else if(e.key < p->data.key) p->lchild = pnode;
             else p->rchild = pnode;
             return True;
         }
         else return False;
     }
     
     /*删除*/
     void Delete(BiTree &T){
         if(p->lchild == nullptr){
             q = p;
             p = p->rchild;
             free(q);
         }else if(p->rchild == nullptr){
             q = p;
             p = p->lchild;
             free(q);
         }else{
             q = p;
             s = p->lchild;
             while(s->rchild){
                 q = s;
                 s = s->rchild;
             }
             p->data = s->data;
             if(q != p) q->rchild = s->lchild;
             else q->lchild = s->lchild;
             free(s);
         }
     }
     ```

4. **平衡二叉树**

   ```c
   /*平衡二叉树的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1*/
   typedef struct BSTNode{
       ElemType data;
       int bf;//左子树深度-右子树深度
       struct BSTNode *lchild, *rchild;
   }BSTNode, *BSTree;
   /*二叉平衡树的旋转分为四种类型，需要理解其中的原理*/
   ```

5. **B-树**

   * 一棵m阶的B-树，或为空树，或为满足下列特性的m叉树：

     1. 树中每个结点至多有m棵子树。
     2. 若根结点不是叶子结点，则至少有两棵子树。
     3. 除根之外的所有非终端结点至少有$\lceil{m/2}\rceil$棵子树。
     4. 叶子结点都出现在同一层次上，且不带信息。

   * B-树的存储结构

     ```c
     #define m 3 //B-树的阶数
     typedef struct BTNode{
         int keynum;
         struct BTNode *parent;
         KeyType key[m + 1];//0号单元不用
         struct BTNode *ptr[m + 1];
         Record *recptr[m + 1];//0号单元不用
     }BTNode, *BTree;
     ```

   * 关键字的数目比子树的数目要少1。

   * B-树的插入和删除(掌握思想，尤其是结点的分裂和合并)

6. B+树：叶子结点中包含了全部关键字的信息，所有的非终端结点可以看成是索引。

7. 键树：又称数字查找树。

8. **哈希表**：

   * 哈希函数的构造：

     1. 直接定址法：取关键字或关键字的某个线性函数值为哈希地址。

     2. 数字分析法。

     3. 平方取中法。

     4. 折叠法。

     5. 除留余数法：取关键字被某个不大于表长m的数p除后所得余数为哈希地址。

        一般情况下，可选p为质数或不包含小于20的质因数的合数。

     6. 随机数法。

   * 哈希冲突的处理：

     1. 开放定址法：
        * 线性探测再散列，$ 1，2，3，\cdots, m-1$
        * 二次探测再散列，$1^2, -1^2, 2^2, -2^2, 3^2, \cdots,\pm{k^2}$
        * 伪随机探测再散列
     2. 再哈希法
     3. 链地址法
     4. 建立一个公共溢出区

   * 哈希表的装填因子定义为
     $$
     \alpha = \frac{表中填入的记录数}{哈希表的长度}
     $$


# Unit 9 : 排序

1. **稳定排序与不稳定排序**：稳定是指**相等元素**在排序前后的相对位置不发生改变。

2. **直接插入排序**：

   ```c++
   void InsertSort(List &L){
   	for(int i = 2; i <= length; i++){
           if(L[i] < L[i-1]){
               L[0] = L[i];
               for(int j = i-1; L[j] > L[0]; j--){
                   L[j+1] = L[j];
               }
               L[j] = L[0];
           }
       }
   }
   /*也有对直接插入排序的优化算法，如折半插入排序，思想类似于先二分查找到插入的最佳位置，然后移动位置*/
   ```

3. **希尔排序**：

   希尔排序又称"缩小增量排序"。

   大致思想：按增量将原序列分成多个小序列，各自进行插入排序。因为有多个增量，所以上一步要进行多次。

4. **快速排序**：

   ```C++
   void FastSort(List &L, start, end){//对[start, end]这个区域进行快速排序
   	//快排的核心思想是把比中心值大的元素统统放在中心值的右边，小的放在中心值的左边
   	key = List[start];//选定快排的中心值
   	s = start;
   	e = end;//设置两个伪指针,采用两头向中间靠拢的策略
   	while(s < e){
           //先移动右指针，找到合适的值填到中心值的位置
   		while(List[e] > key && e > s) e--;//值比中心值大，说明位置合适，需继续往左走，1.直到找到了比中心值小的值，2.或者说发现没有这种值，都需要退出循环
           List[s] = List[e];//把不合适的值移到左边来
           //现在发现我们只改变了，List[s]的值，List[e]位置的值还是原来那个不合适的值。此时我们就需要移动左指针，找到一个合适的值来填到List[e]的位置
           while(List[s] < key && e > s) s++;//值比中心值小，说明位置合适，需继续往右走，1.直到找到了比中心值大的值，2.或者说发现没有这种值，都需要退出循环
           List[e] = List[s];//现在List[s]的值就合理了
           /*如此反复循环,直到s == e退出循环*/
   	}
       /*退出循环后我们发现，此时恰好给中心值腾出了一个位置*/
       List[s] = key;//将中心值填入即可
       /*对中心值两边同样进行快排*/
       if(start < s - 1) FastSort(L, start, s - 1);
       if(s + 1 < end) FastSort(L, s + 1, end);
   }
   ```

5. 简单选择排序(如其名，简单)。

6. **堆排序**：

   * 小顶堆需满足以下条件：
     $$
     \begin{cases}
     k_i\leq{k_{2i}}\\
     k_i\leq{k_{2i+1}}
     \end{cases}
     $$
     大顶堆需满足以下条件：
     $$
     \begin{cases}
     k_i\geq{k_{2i}}\\
     k_i\geq{k_{2i+1}}
     \end{cases}
     $$

   * 堆排序的实现：

     ```c
     /*大顶堆*/
     void HeadAdjust(List &L, int start, int end){
         key = L[start];
         for(m = start * 2; m <= end; m *= 2){
             if(L[m+1] > L[m]) m = m + 1;
             if(key >= L[m]) break;
             L[start] = L[m];//交换位置
             start = m;
         }
         L[start] = key;
     }
     
     void HeapSort(List &L){
         /*建立大顶堆*/
         for(int i = length / 2; i > 0; i--){
             HeapAdjust(L, i, length);
         }
         for(int i = length; i > 1; i--){
             temp = L[1];
             L[1] = L[i];
             L[i] = temp;
             HeapAdjust(L, 1, i-1);
         }
     }
     ```

     

7. **归并排序**

   ```c
   void Merge(List &T, List T2, int start, int m, int end){
       int a = start;
       int b = m + 1;//设置两个伪指针
       int c = 0;//设置T的伪指针
       while(a <= m && b <= end){
           if(T2[a] < T2[b]){
               T[++c] = T[a];
               a++;
           }else{
               T[++c] = T[b];
               b++;
           }
       }
       while(a <= m){
           T[++c] = T[a];
           a++;
       }
       while(b <= end){
           T[++c] = T[b];
           b++;
       }
   }
   void MergeSort(List L, List &T,int start, int end){
       if(start == end){
           T[start] = L[start];
       }else{
           m = (start + end) / 2;
           MergeSort(L, T2, start, m);
           MergeSort(L, T2, m+1, end);
           Merge(T, T2,start, m ,end);
       }
   }
   ```

   

8. 基数排序

   基数排序就是`distribute`和`collect`方法的多次使用。

   依次根据各个关键字将原序列分配成一组列表，再把列表收集起来串成一串，如此反复，直到完成排序。

9. **各种排序方法的比较**：

   | 排序方法     | 平均时间           | 最佳情况           | 最坏情况           | 辅助空间         | 稳定性 |
   | ------------ | ------------------ | ------------------ | ------------------ | ---------------- | ------ |
   | 简单选择排序 | $O(n^2)$           | $O(n)$             | $O(n^2)$           | $O(1)$           | 不稳定 |
   | 直接插入排序 | $O(n^2)$           | $O(n)$             | $O(n)$             | $O(1)$           | 稳定   |
   | 折半插入排序 | $O(n^2)$           | $O(n\cdot\log{n})$ | $O(n^{2})$         | $O(1)$           | 不稳定 |
   | 冒泡排序     | $O(n^2)$           | $O(n)$             | $O(n^2)$           | $O(1)$           | 稳定   |
   | 希尔排序     | $O(n^{1.3})$       | $O(n)$             | $O(n^2)$           | $O(1)$           | 不稳定 |
   | 堆排序       | $O(n\cdot\log{n})$ | $O(n\cdot\log{n})$ | $O(n\cdot\log{n})$ | $O(1)$           | 不稳定 |
   | 归并排序     | $O(n\cdot\log{n})$ | $O(n\cdot\log{n})$ | $O(n^2)$           | $O(n)$           | 稳定   |
   | 快速排序     | $O(n\cdot\log{n})$ | $O(n\cdot\log{n})$ | $O(n^2)$           | $O(\log{n})$     | 不稳定 |
   | 基数排序     | $O(d\cdot(n+r))$   | $O(d\cdot(n+r))$   | $O(d\cdot(n+r))$   | $O(d\cdot(n+r))$ | 稳定   |

10. 地址排序(理解思想)

11. 外部排序的读写次数：$物理块的数目\times(2\times归并趟数+2)$

12. 败者树(理解思想)

13. 置换选择排序(败者树的应用，理解思想)

14. 最佳归并树：若$(m-1)MOD(k-1)=0$则不需要加虚段，否则需要加$k-1-(m-1)MOD(k-1)$个虚段

